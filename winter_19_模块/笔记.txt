1、模块：
		借助已实现的函数实现某种无法完成的功能
		具有相同类别的一组功能
		
2、模块的分类：
	内置模块
	第三方模块/扩展模块
	自定义模块（py文件）
	
3、模块的优点：
		分类管理方法
		节省内存
		提供更多功能

4、导入模块：
	# 导入文件不加后缀名
	# 模块的名字必须满足命名规范，一般都是小写字母开头
	# import 模块 相当于执行这个模块的py文件
	# 一个模块不会重复导入
		
5、导入模块后，发生了什么？
	1、找到这个模块
	2、创建一个属于模块的内存空间
	3、执行该模块
	4、建立这个模块所在的命名空间和模块之间的引用关系
	
6、from...import...

7、模块相关知识：
	1、把模块当成脚本运行：从本模块中反射本模块的变量
	if __name__ = '__main__': # 你希望某段代码，再被当做模块导入时不要执行
		所有不需要调用就能执行的内容
	import sys
	sys.modules[__name__]
	2、模块搜索路径 
	sys.path
	一个自定义模块能否导入，就看sys.path列表中是否有这个模块所在的绝对路径
	
8、pyc编译文件
	模块导入时，python解释器执行编译
	当一个文件作为一个脚本被导入时，就会在这个文件所在的目录的pycache下生成一个编译好的文件，
	为了之后导入这个文件的时候直接读这个编译好的pyc文件，这样做可以节省一些导入时候的时间
	注：如果导入的文件有改动，python解释器会自动重新导入修改后的文件
	
9、重新加载
	无论什么时候只要import了一次，在同一个文件下一次import相同模块时，结果都不会改变，程序是感知不到的（不论模块是否发生改变）
	
10、循环引用
	在模块的导入中不要产生循环引用，会发生问题
	
11、包
	集合了一组py文件，提供了一组复杂功能
	包中至少拥有一个__init__.py文件
	当提供的功能比较复杂，一个py文件写不下时

12、导入包的模块
	import 包.包.模块
	包.包.模块.变量
	
	from 包.包 import 模块 # 推荐
	模块.变量
	
13、导入包（相当于执行了__init__.py文件） 
	需要自己设计init文件来完成一些模块的导入
	未来自己写包时或读源码时，会用到
	
	导入方式：
		包的绝对导入
		包的相对导入：使用了相对导入模块只能被当做模块执行，不能作为脚本执行
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	