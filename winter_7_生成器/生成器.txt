1、生成器的本质是迭代器

2、生成器的三种生成方法：
	（1）通过生成器函数
	（2）通过生成器表达式创建生成器
	（3）通过数据转换
	
	生成器函数：
	函数中包含了yield的就是生成器函数
	注：生成器函数被执行，获取的是生成器，而不是执行函数
	
	生成器表达式：
	(结果 for 变量 in 可迭代对象 if 筛选条件)
	
	
3、在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。
	
   最后一个yield之后在执行__next__()会报错
   
4、取值：
	__next__()可以让生成器向下执行一次
	send()也可以让生成器向下执行一次，并给上一个yield传值，但是，第一个不能用send（），最后一个也不能用send()
	

5、列表推导式：使用[]生成list
	lst = [i for i in range(1, 101) if i % 2 == 0]

6、生成器表达式和列表推导式的语法基本一样的，只是把[]替换成()

7、生成器表达式和列表推导式的区别：
	（1）列表推导式比较耗内存，一次性加载。
		 生成器表达式几乎不占用内存，使用时才分配和使用内存
	（2）得到的值不一样，列表推导式得到一个列表，生成器表达式获取的是一个生成器
	
8、 def func():
		print(111)
		yield 222


	g = func()
	g1 = (i for i in g) # 生成器g1，数据来源于g
	g2 = (i for i in g1) #生成器g2,数据来源于g1
	print(list(g))	# 获取g中的数据，这时func()才会执行，打印111，获取222，g完毕
	print(list(g1)) # 获取g1中的数据，数据来源于g，但g已经取完了，g1也就没有数据了
	print(list(g2))
注：生成器会在值得的时候才拿值

9、集合推导式：生成一个集合，自带去重功能

10、各种推导式：
	列表推导式 [结果 for 变量 in 可迭代对象 if 筛选条件]
	字典推导式 {结果 for 变量 in 可迭代对象 if 筛选条件} #结果=>key:value的形式
	集合推导式 {结果 for 变量 in 可迭代对象 if 筛选条件} 结果=> key的形式

11、def add(a,b):
		return a+b
	def test():
    for i  in range(4):
        yield i
	g = test()
	for n in [2,10]
		g = (add(n,i)for i in g)
	print(list(g))
	此式子始终不拿值，直到最后一次，才拿值